[{"content":"The game I want to make\rThe game I want to make is similar to \u0026ldquo;Space Invaders\u0026rdquo;. The player can move the plane left and right, launch laser to attack enemies. Enemies would gradually approach to the plane. When all enemies are destroyed or the enemies are too close to the plane, game over.\nHow to use my collision system\rTo make this game, collision system is very important. It is used to detect whether the laser has hit the enemies, then trigger the hit event to destroy those enemies. The collision system is also used to create boundaries to control the range of movement of the plane and enemies.\nAudio System\rIn this game, I want to use the audio system provided by Subham More. Here is the link of this system(Audio System). I want to make the laser sound when launch laser, and explosion sound when enemies are destroyed. Also I want to make a background music using this system.\n","date":"2024-11-15T00:00:00Z","image":"https://joumik.github.io/p/game-engine-ii-final-project-proposal/engine_hu4521113101166852132.jpg","permalink":"https://joumik.github.io/p/game-engine-ii-final-project-proposal/","title":"Game Engine II Final Project Proposal"},{"content":"What the system does\rThis system is a collision system, it provides two different collision components, SphereCollisionComponent and BoxCollisionComponent. You can use this system to generate OnComponentHit event, OnComponentBeginOverlap event and OnComponentEndOverlap event.\nThis system uses the BVH structure and some other methods to reduce the performance cost. It also uses linear interpolation and binary search to avoid tunneling happen when the actor moves too fast.\nHow to use the system\rSet Up\rThe set up is very easy:\nDownload the Zip file I provided and unzip Put it to your Engine folder Set the correct props for Collision system just like what you did for Graphics system Add Math system as the reference of Collision system Add Collision system as the reference of MyGame Collision Manager\rCollision manager handles collision detection from collision component set and broadcast certain events when those events happened, it also builds BVH for those components. The way it works is pretty complicated but users only need to know how to use the interfaces provided.\nCollision manager uses the singleton pattern, if you want to use collision manager, Call the function CollisionManager::GetCollisionManager() first to get the variable.\n1 2 3 4 5 6 void AddCollisionComponent(BaseCollisionComponent\u0026amp; comp); void RemoveCollisionComponent(BaseCollisionComponent\u0026amp; comp); static CollisionManager* GetCollisionManager(); void Begin(); void Update(); void Destroy(); You mush call AddCollisionComponent() to add the component to the component set, if it is not set to the collision set, it would not do the collision detection;\nYou mush call RemoveCollisionComponent() before you destroy the component;\nYou should call Begin() in the beginning of the game after you add all the components to the component set;\nYou should call Update() in each update and call Destroy() when you finish the game;\nCollision Component\rSphereCollisionComponent and BoxCollisionComponent are the child classes of BaseCollisionComponent\nSet Size\rSphereCollisionComponent:\n1 inline void SetRadius(float i_radius) { radius = i_radius; } BoxCollisionComponent:\n1 inline void SetExtend(Math::sVector i_extend) { extend = i_extend; } Set Initial Position\r1 inline void SetPosition(Math::sVector i_position) { position = i_position; } Notice: This function is only used to set the initial position. If you want to change the component\u0026rsquo;s position when it moves, please see 2.3.5 Movement\nCollision Event\rYou can set the collision event of collision component to NoCollision, Overlap, or Hit.\n1 2 3 4 5 6 enum class CollisionEvent { NoCollision, Overlap, Hit }; The function you need to set the collision event is SetCollisionEvent(). By default, it would be set to Hit.\n1 inline void SetCollisionEvent(CollisionEvent i_collisionEvent = CollisionEvent::Hit) { collisionEvent = i_collisionEvent; } Rules:\nActor A Actor B Collision Event Generated Hit Hit Hit Event Hit Overlap Overlap Event Overlap Hit Overlap Event Overlap Overlap Overlap Event NoCollision Any None Any NoCollision None Collision Component Type\rYou can set the component type to Static or Dynamic.\n1 2 3 4 5 enum class CollisionComponentType { Static, Dynamic }; The function you need to set the component type is SetCollisionComponentType(). By default, it would be set to Dynamic.\n1 inline void SetCollisionComponentType(CollisionComponentType i_collisionComponentType = CollisionComponentType::Dynamic) { collisionComponentType = i_collisionComponentType; } Because the StaticBVH would be only built once when CollisionManager::GetCollisionManager()-\u0026gt;Begin() is called, while the DynamicBVH would be built every time CollisionManager::GetCollisionManager()-\u0026gt;Update() is called. So it is good for performance if the component type is set to static.\n\u0026ldquo;You must set the component type to Dynamic if you want the component to move.\u0026quot;\nMovement\rIf you want to move the component to a new position, there are some steps you need to follow.\nAgain, please make sure the component type has set to Dynamic\nMust call TryMoveTo() first.\n1 2 3 4 5 6 7 void eae6320::AControlledActor::Update(const float i_elapsedSecondCount_sinceLastSimulationUpdate) { if (rigidBodyState-\u0026gt;velocity.GetLength() != 0) { SphereComp-\u0026gt;TryMoveTo(rigidBodyState-\u0026gt;PredictFuturePosition(i_elapsedSecondCount_sinceLastSimulationUpdate)); } } Notify Collision manager to do the collision detection by calling Update(). Collision manager would decide whether components can move to the new position and set them to the correct position. 1 2 //Update Collision Collision::CollisionManager::GetCollisionManager()-\u0026gt;Update(); Bind Event\rThere are four events provided by collision component\n1 2 3 4 Delegate\u0026lt;const BaseCollisionComponent\u0026amp;\u0026gt; OnComponentHit; Delegate\u0026lt;const BaseCollisionComponent\u0026amp;\u0026gt; OnComponentBeginOverlap; Delegate\u0026lt;const BaseCollisionComponent\u0026amp;\u0026gt; OnComponentEndOverlap; Delegate\u0026lt;const Math::sVector\u0026amp;\u0026gt; UpdatePositionAfterCollision; OnComponentHit event would broadcast to the functions binded to it the info of the component it hits. OnComponentBeginOverlap event would broadcast to the functions binded to it the info of the component it just overlaps. OnComponentEndOverlap event would broadcast to the functions binded to it the info of the component it just finishes overlapping with. UpdatePositionAfterCollision event would broadcast to the functions binded to it the position of itself after collision detection. Example of binding event\n1 2 3 4 5 6 7 8 9 10 eae6320::AControlledActor::AControlledActor(eae6320::Graphics::Mesh* i_mesh, eae6320::Graphics::Effect* i_effect) { //Bind Event SphereComp-\u0026gt;UpdatePositionAfterCollision.Add(this, \u0026amp;AControlledActor::UpdatePosition); } void eae6320::AControlledActor::UpdatePosition(const Math::sVector\u0026amp; safePosition) { SetPosition(safePosition); } 1 2 3 4 5 6 7 8 9 10 eae6320::AOverlapBeginTestActor::AOverlapBeginTestActor(eae6320::Graphics::Mesh* i_mesh, eae6320::Graphics::Effect* i_effect) { //Bind Event boxComp-\u0026gt;OnComponentBeginOverlap.Add(this, \u0026amp;AOverlapBeginTestActor::OnComponentBeginOverlap); } void eae6320::AOverlapBeginTestActor::OnComponentBeginOverlap(const Collision::BaseCollisionComponent\u0026amp;) { //Your code here } What you need to notice\rWhen doing the final project, I found that deleting the pointer variable of the collision component added to the collision manager in the middle of the game would crash the game (even if you have already called RemoveCollisionComponent() to remove it). So if you want to use this system, please do not delete the pointer variables of the collision component in the middle of the game. Instead, delete them at the end of the game, which means you should delete all those variables at your CleanUp() function. I may fix this issue if I have enough time but for now, please follow it.\nHow I used what I have learned this semester\rThe way to set up an engine system and make it work with other system; The way to make graphics debugging, thanks for that I did not stuck on any issue for a long time; Taking the advantage of logging system and use it to test whether the demo works as I expected; Anything learned or struggled\rHow to build BVH; 1 2 3 4 5 6 7 8 9 10 11 12 struct BVHNode { BoundingBox bounds; std::unique_ptr\u0026lt;BVHNode\u0026gt; left; std::unique_ptr\u0026lt;BVHNode\u0026gt; right; std::vector\u0026lt;BaseCollisionComponent*\u0026gt; components; bool IsLeaf() const { return left == nullptr \u0026amp;\u0026amp; right == nullptr; } }; The way to use custom hash rule to store pairs in hash set; 1 2 3 4 5 6 7 8 // custom hash function struct CollisionPairHash { std::size_t operator()(const CollisionPair\u0026amp; pair) const { return std::hash\u0026lt;void*\u0026gt;()(pair.componentA) ^ std::hash\u0026lt;void*\u0026gt;()(pair.componentB); } }; std::unordered_set\u0026lt;CollisionPair, CollisionPairHash\u0026gt; currentOverlaps; How the delegate system works;\nThe optimization methods for collision system;\nThe way to handle tunneling problem;\n1 2 Math::sVector Lerp(const Math::sVector\u0026amp; start, const Math::sVector\u0026amp; end, float t); Math::sVector PerformBinarySearch(const Math::sVector\u0026amp; start, const Math::sVector\u0026amp; end, float low, float high, BaseCollisionComponent\u0026amp; comp); Collision System Download\rDownload and have a try: CollisionSystem\n","date":"2024-11-14T00:00:00Z","image":"https://joumik.github.io/p/game-engine-ii-collision-system/engine_hu4521113101166852132.jpg","permalink":"https://joumik.github.io/p/game-engine-ii-collision-system/","title":"Game Engine II Collision System"},{"content":"Gif of My Collision System Demo\rThis demo shows how the collision system works, the green one enabled hit event, red one enabled overlap begin event, yellow one enabled overlap end event\nStatic/Dynamic\rFor better performance, I made a CollisionComponentType variable for each collision component:\n1 2 3 4 5 enum class CollisionComponentType { Static, Dynamic }; If the component is set to static, then it would never move so the collision between it and other components would not be detected actively. If the component is set to dynamic and it moved in current update, it would actively detect whether there are any component collide with it and broadcast certain event.\n1 2 // only update the dynamic components that are moving in this update if (comp-\u0026gt;GetCollisionComponentType() != CollisionComponentType::Dynamic || !comp-\u0026gt;bIsMoving) continue; BVH\rFor better performance further, I implemented a BVH structure for the collision system. The structure of each BVH node is like:\n1 2 3 4 5 6 7 8 9 10 11 12 struct BVHNode { BoundingBox bounds; std::unique_ptr\u0026lt;BVHNode\u0026gt; left; std::unique_ptr\u0026lt;BVHNode\u0026gt; right; std::vector\u0026lt;BaseCollisionComponent*\u0026gt; components; bool IsLeaf() const { return left == nullptr \u0026amp;\u0026amp; right == nullptr; } }; Considering the difference of static and dynamic components, I made two variables in CollisionManager to store the BVH info:\n1 2 std::unique_ptr\u0026lt;BVHNode\u0026gt; staticBVH; std::unique_ptr\u0026lt;BVHNode\u0026gt; dynamicBVH; The staticBVH would be only built once in the very beginning of the game because static components never move. The dynamicBVH would be built in each update to make sure the info is correct.\nDemo Implement\rTo test whether the collision system works as I expected, I made a demo as shown in 1. Gif of My Collision System Demo. In this demo, I made three different actor classes, they are used to test different collision event(hit, overlap begin, overlap end). In each class, I used delegate system to bind the function with certain event, so when certain event happened the function can be triggered. The way to do it is very similar to how you bind event on Unreal. Here is an example of one class:\n1 2 3 4 5 6 7 8 9 10 11 12 eae6320::AHitTestActor::AHitTestActor(eae6320::Graphics::Mesh* i_mesh, eae6320::Graphics::Effect* i_effect) : GameFramework::AActor(i_mesh, i_effect) { boxComp = new Collision::BoxCollisionComponent(); boxComp-\u0026gt;SetCollisionEvent(Collision::CollisionEvent::Hit); boxComp-\u0026gt;SetCollisionComponentType(Collision::CollisionComponentType::Static); Collision::CollisionManager::GetCollisionManager()-\u0026gt;AddCollisionComponent(*boxComp); //Bind Event boxComp-\u0026gt;UpdatePositionAfterCollision.Add(this, \u0026amp;AHitTestActor::UpdatePosition); boxComp-\u0026gt;OnComponentHit.Add(this, \u0026amp;AHitTestActor::OnComponentHit); } What\u0026rsquo;s Next\rIncremental update the dynamicBVH to avoid the entire reconstruction to optimal performance; Find other code logic that can be optimized and fix any potential issues; Attempt to create a visual interface to enhance the user experience Collision System Demo\rDownload and have a try: MyGame\n","date":"2024-11-07T00:00:00Z","image":"https://joumik.github.io/p/game-engine-ii-engine-system-update-02/engine_hu4521113101166852132.jpg","permalink":"https://joumik.github.io/p/game-engine-ii-engine-system-update-02/","title":"Game Engine II Engine System Update 02"},{"content":"Collision Component\rIn my collision system, I made a BaseCollisionComponent class and two child classes BoxColliisionComponent and SphereCollisionComponent. I use an enum class to identify the shape of the collision component. Users utilising the collision component can enable/disable the hit event and overlap event based on their requirements by calling the functions EnableHitEvent(bool) and EnableOverlapEvent(bool).\n1 2 3 4 5 6 enum class CollisionType { None, Box, Sphere }; Delegate System\rSimilar to unreal, I made a delegate system for collision system to broadcast the events(OnComponentHit, OnComponentBeginOverlap, OnComponentEndOverlap), this design make the whole system more flexible and do not need to care what users want to do.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 template\u0026lt;typename... Args\u0026gt; class Delegate { public: using CallbackType = std::function\u0026lt;void(Args...)\u0026gt;; void Add(CallbackType callback) { callbacks.push_back(callback); } void RemoveAll() { callbacks.clear(); } void Broadcast(Args... args) { for (auto\u0026amp; callback : callbacks) { callback(args...); } } private: std::vector\u0026lt;CallbackType\u0026gt; callbacks; }; class BaseCollisionComponent { public: Delegate\u0026lt;const BaseCollisionComponent\u0026amp;\u0026gt; OnComponentHit; Delegate\u0026lt;const BaseCollisionComponent\u0026amp;\u0026gt; OnComponentBeginOverlap; Delegate\u0026lt;const BaseCollisionComponent\u0026amp;\u0026gt; OnComponentEndOverlap; //others } Collision Manager\rI made a CollisionManager class, that uses the Singleton pattern. It is responsible for updating the positions of all components and comparing the detected overlap state in each frame with the state of the previous frame to ensure the correct triggering of OverlapRegister and OverlapEnd events, as well as the Hit event. To achieve this, I used two sets to cache the overlap pairs of the current and previous frames (current Overlaps and previous Overlaps).\nIn order to improve efficiency and avoid duplicate detection of the same collision pairs in the same frame, I made a collisionCache to cache the collision pairs that have already been detected in the current frame. This way, even if the component enters the Update process multiple times in the same frame, it will not repeatedly detect collisions that have already been processed.\nThe Way I Do\nCache mechanism: Add a collisionCache in CollisionManager to store collision pairs that have been detected in each frame.\nQuery cache before detection: Before each collision detection, check if collisionCache already contains the current component pair. If it already exists, skip detection. If it does not exist, perform collision detection and add the current component pair to collisionCache.\nClear cache per frame: Clear collisionCache at the end of each frame for re detection in the next frame.\nLocation Update\rIn order to achieve smooth movement and position update of components, I use linear interpolation (Lerp) to calculate the smooth transition from the current position to the target position, ensuring that collision detection can be accurately performed at each interpolation step. By calculating the interpolation points on the original and target position paths, it prevents being missed when there are other components on the path\nWhat\u0026rsquo;s next\rI would make the BVH structure to speed up the collision detection efficiency. After I finish it, I will make a demo to test whether everything works great.\n","date":"2024-11-01T00:00:00Z","image":"https://joumik.github.io/p/game-engine-ii-engine-system-update-01/engine_hu4521113101166852132.jpg","permalink":"https://joumik.github.io/p/game-engine-ii-engine-system-update-01/","title":"Game Engine II Engine System Update 01"},{"content":"Gif of My Game\rBinary Geometry File\rContents\rThe contents stored in a binary file are, in order, the number of vertex, vertex data, the number of index, index data.\n04 00 33 33 B3 BF CD CC 0C BF 9A 99 19 40 33 33\nB3 BF CD CC 0C BF 9A 99 19 40 CD CC CC 3F CD CC\n0C BF 00 00 90 C0 CD CC CC BF CD CC 0C BF 00 00\n90 C0 06 00 00 00 01 00 02 00 00 00 02 00 03 00\nAdvantages\rAdvantages of Binary Formats:\nEfficient Storage and Transmission: Binary formats typically take up less space than human-readable formats because they store raw data directly rather than using characters. Reduced Data Redundancy: Binary formats avoid much of the redundancy present in human-readable formats (like tags, whitespace), improving efficiency further. Faster Processing: Since binary formats are more compact, computers can parse and process them more quickly, which is crucial for performance-sensitive applications. Advantages of Human-Readable Format:\nReadability and Easier Debugging: Human-readable formats are easy to understand, allowing developers to directly view and edit data when debugging and maintaining code. Ease of Modification: Developers and users can easily modify these files manually, which is useful in development, configuration, and testing environments for quick edits. The benefit of using binary formats at run-time but human-readable formats to store the data in source control:\nThe higher the runtime efficiency, the better, so using binary files has obvious advantages. However, in source control, the higher the readability, the better. Therefore, using human readable files is more advantageous. By compiling human readable files into binary files before running, the advantages of both file formats are fully utilized.\nPlatform Support\rBy checking the binary files generated for Direct3D and OpenGL platforms, I found the built binary geometry files are the same. The reason is also very simple, because the reading of binary files is platform independent and has nothing to do with which platform it runs on.\nExtract Data\r1 2 3 4 5 6 7 uint16_t vertexCount = *reinterpret_cast\u0026lt;uint16_t*\u0026gt;(buffer); currentOffset += sizeof(vertexCount); Graphics::VertexFormats::sVertex_mesh* vertexData = reinterpret_cast\u0026lt;Graphics::VertexFormats::sVertex_mesh*\u0026gt;(currentOffset); currentOffset += sizeof(Graphics::VertexFormats::sVertex_mesh) * vertexCount; uint16_t indexCount = *reinterpret_cast\u0026lt;uint16_t*\u0026gt;(currentOffset); currentOffset += sizeof(indexCount); uint16_t* indexData = reinterpret_cast\u0026lt;uint16_t*\u0026gt;(currentOffset); Compare\rThe binary format has significant advantages in storage space and running efficiency compared to the previous Lua format\nSpeed of loading binary file Speed of loading Lua file Size of binary file Size of Lua file Game Sample\rDownload and have a try: MyGame\n","date":"2024-10-25T00:00:00Z","image":"https://joumik.github.io/p/game-engine-ii-assignment08/engine_hu4521113101166852132.jpg","permalink":"https://joumik.github.io/p/game-engine-ii-assignment08/","title":"Game Engine II Assignment08"},{"content":"Introduction\rThe Engine System I want to make is a Collision System which handles interactions between actors in the game. The current implementation is designed to be simple and efficient, supporting Box and Sphere Components for collision detection. It uses a Bounding Volume Hierarchy (BVH) with Axis-Aligned Bounding Boxes (AABB) to optimize collision checks, making it suitable for basic physics and actor interaction in a 3D environment.\nKey Features\rBox and Sphere Collision: The system supports collision detection for actors defined as boxes or spheres. These are the simplest shapes to work with and are commonly used for fast collision detection. BVH: The system uses BVH with AABB to speed up collision queries. This hierarchical structure helps in minimizing the number of collision checks by narrowing down potential collisions between actors. Potential Future Support: If time allows, support for Oriented Bounding Boxes (OBB) and Capsule Components may be added, which would provide more efficient and accurate collision for actors. How to Use the Features\rClasses and Interfaces: ​\tBoxComponent and SphereComponent: These define the shape and size of the colliders.\n​\tBVHNode: Represents nodes in the bounding volume hierarchy, helping to group and organize collision actors for efficient processing.\n​\tCollisionManager: Manages the overall collision system, running checks and updating collision status between actors.\nFunctions: ​\tUpdatePosition(): Users can update collision components manually to make them follow actors.\n​\tTryMove(): Returns whether an actor can move to one specific position. If it is collided with another actor, return false.\n​\tCheckCollision(): Returns whether two actors are colliding based on their components.\n​\tUpdateBVH(): Reorganizes the BVH tree to reflect changes in actor positions or sizes.\nWhat Will Be Implemented\rBox and Sphere Components for collision detection.\nA BVH (AABB) system to optimize collision queries.\nSimple API functions to add components and check collisions.\nChallenges and Stretch Goals\rChallenges: Managing the performance of the BVH system, especially in complex scenes with many actors, could be tricky. Ensuring that the hierarchy updates efficiently when actors move or change. Stretch Goals: If time permits, adding support for more complex shapes like Capsule would improve the accuracy and versatility of the system. And adding OBB as an option for BVH would improve its efficiency. ","date":"2024-10-25T00:00:00Z","image":"https://joumik.github.io/p/game-engine-ii-engine-system-proposal/engine_hu4521113101166852132.jpg","permalink":"https://joumik.github.io/p/game-engine-ii-engine-system-proposal/","title":"Game Engine II Engine System Proposal"},{"content":"Gif of My Game\rReferences to MayaMeshExporter\rThere is no reference is needed for MayaMeshExporter to successfully build\nProjects depend on MayaMeshExporter\rThere is no project depends on MayaMeshExporter\nMaya Plug-in\rI didn\u0026rsquo;t export the unused data. Considering that if there is a real demand for these unused data in the future, a lot of work needs to be done to support them. It may be more convenient to add the data at that time, and it will be clearer to know what data I need and what format I want it to be in.\nModel with too Many Vertices\rIt would crash if a mesh with too many vertices is rendered. Because the current logic of the engine is to have the GPU process all the vertices of a model at once, which may cause communication and rendering bottlenecks between the CPU and GPU, leading to crashes. This problem can be solved through methods such as batch uploading in the future\nScreenshot of Debugging\rGame Sample\rDownload and have a try: MyGame\n","date":"2024-10-18T00:00:00Z","image":"https://joumik.github.io/p/game-engine-ii-assignment07/engine_hu4521113101166852132.jpg","permalink":"https://joumik.github.io/p/game-engine-ii-assignment07/","title":"Game Engine II Assignment07"},{"content":"Gif of My Game\rAdvantages of Human-readable Asset Files\rCreators can easily make formatting changes in the later stages; Readers can quickly understand the file structure and what each section represents; People who need to use this type of file can easily write code to retrieve its contents; Mesh Files\rHere is an example of my lua structure\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 return { vertex = { { -0.4, -0.4, 0.0 }, { 0.4, -0.4, 0.0 }, { 0.4, 0.4, 0.0 }, { -0.4, 0.4, 0.0 }, }, index = { 0, 1, 2, 0, 2, 3, }, } The reason I do it in this way is that it is a highly readable structure. By using keywords like \u0026ldquo;vertex\u0026rdquo;, the reader would quickly understand the usage of each block.\nScreenshot of Debugging\rGame Sample\rDownload and have a try: MyGame\n","date":"2024-10-04T00:00:00Z","image":"https://joumik.github.io/p/game-engine-ii-assignment06/engine_hu4521113101166852132.jpg","permalink":"https://joumik.github.io/p/game-engine-ii-assignment06/","title":"Game Engine II Assignment06"},{"content":"Gif of My Game\rPress “WASD” to move object\nPress \u0026ldquo;F3\u0026rdquo; to change mesh\nPress \u0026ldquo;$\\uparrow$, $\\rightarrow$, $\\downarrow$, $\\leftarrow$\u0026rdquo; to move camera\nActor\rIntroduction\rLike Unreal, I use AActor to represent the objects that can be put in the scene.\n1 2 3 4 5 6 7 8 class AActor : public UObject, public eae6320::Graphics::cRenderableObject { public: AActor(eae6320::Graphics::Mesh* i_mesh, eae6320::Graphics::Effect* i_effect); ~AActor(); virtual void CleanUp(); }; If the user wants to create an object in the scene, he needs to create an actor instance first, then uses the functions provided by Actor and its parent classes.\n1 2 3 4 5 6 7 8 9 //.h //Actors eae6320::GameFramework::AActor* house = nullptr; eae6320::GameFramework::AActor* chimney = nullptr; //.cpp //Actor house = new eae6320::GameFramework::AActor(mesh01, effect01); chimney = new eae6320::GameFramework::AActor(mesh02, effect02); Now the functions the user needs mainly in its parent class cRenerabaleObject, a class in Graphics namespace that provides the functions to change mesh or effect and submit necessary data to draw.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class cRenderableObject { public: eae6320::Physics::sRigidBodyState* rigidBodyState = nullptr; void CleanUp(); void ChangeMesh(Mesh* new_mesh); void ChangeEffect(Effect* new_effect); void SubmitMeshWithEffectToDraw(const float i_elapsedSecondCount_sinceLastSimulationUpdate); protected: inline void SetMesh(Mesh* i_mesh) { mesh = i_mesh; mesh-\u0026gt;IncrementReferenceCount(); } inline void SetEffect(Effect* i_effect) { effect = i_effect; effect-\u0026gt;IncrementReferenceCount(); } private: Mesh* mesh = nullptr; Effect* effect = nullptr; }; And as shown in the code, it has the variable of sRigidBodyState structure so it can send data to change object\u0026rsquo;s position.\nChange Mesh and Effect\rAs shown in the code of 2.1, if the user needs to change the mesh or effect of one actor, just call SetMesh or SetEffect\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //cMyGame.cpp void eae6320::cMyGame::SwitchShader() { if (!isDiffShader) { house-\u0026gt;ChangeEffect(effect02); } else { house-\u0026gt;ChangeEffect(effect01); } } void eae6320::cMyGame::SwitchMesh() { if (isCubeMesh) { house-\u0026gt;ChangeMesh(mesh03); } else { house-\u0026gt;ChangeMesh(mesh01); } } Submit Data to Render\rAs shown in the code of 2.1, if the user needs to render an actor, all he needs to do is call SubmitMeshWithEffectToDraw, which is a function of cRenderableObject class and be inherited by AActor.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void eae6320::cMyGame::SubmitDataToBeRendered(const float i_elapsedSecondCount_systemTime, const float i_elapsedSecondCount_sinceLastSimulationUpdate) { //...... //Draw Actors { house-\u0026gt;SubmitMeshWithEffectToDraw(i_elapsedSecondCount_sinceLastSimulationUpdate); if (isShow) { chimney-\u0026gt;SubmitMeshWithEffectToDraw(i_elapsedSecondCount_sinceLastSimulationUpdate); } } //...... } Camera Actor\rI make a class called ACameraActor to represent camera, this class store all the necessary data for camera.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class ACameraActor { public: ACameraActor(); ~ACameraActor() = default; void SubmitCameraData(const float i_secondCountToExtrapolate); void Update(const float i_elapsedSecondCount_sinceLastUpdate); void CleanUp(); inline void SetVelocity(Math::sVector velocity) { rigidBodyState-\u0026gt;velocity = velocity; } inline Math::sVector GetVelocity() { return rigidBodyState-\u0026gt;velocity; } inline void SetPosition(Math::sVector position) { rigidBodyState-\u0026gt;position = position; } float verticalFieldOfView_inRadians; float aspectRatio; float z_nearPlane; float z_farPlane; private: eae6320::Physics::sRigidBodyState* rigidBodyState = nullptr; }; Like Actor, I also use sRigidBodyState to control camera\u0026rsquo;s movement.\nPlayer Controller\rIntroduction\rLike Unreal, I put the control of the camera into the player controller, and this is all the player controller does for now.\n1 2 3 4 5 6 7 8 9 10 class APlayerController { public: void Update(const float i_elapsedSecondCount_sinceLastUpdate); void SetCurrentCamera(ACameraActor* newCamera); void SubmitDataToGraphics(const float i_secondCountToExtrapolate); private: ACameraActor* currentCamera = nullptr; }; Change Camera\rIf the user wants to change the camera, just call SetCurrentCamera\nSubmit Camera Data\rTo submit camera data, call SubmitDataToGraphics\n1 2 3 4 5 6 7 void eae6320::cMyGame::SubmitDataToBeRendered(const float i_elapsedSecondCount_systemTime, const float i_elapsedSecondCount_sinceLastSimulationUpdate) { // Player Controller send the binded camera date to graphics { playerController-\u0026gt;SubmitDataToGraphics(i_elapsedSecondCount_sinceLastSimulationUpdate); } } sDataRequiredToRenderAFrame\rStructure\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 struct sColor { float r = 0.f; float g = 0.f; float b = 0.f; float a = 1.f; }; struct sDataRequiredToRenderAFrame { eae6320::Graphics::ConstantBufferFormats::sFrame constantData_frame; std::vector\u0026lt;eae6320::Graphics::ConstantBufferFormats::sDrawCall\u0026gt; constantData_drawCalls; sColor backgroundColor; std::vector\u0026lt;std::pair\u0026lt;eae6320::Graphics::Mesh*\u0026amp;, eae6320::Graphics::Effect*\u0026amp;\u0026gt;\u0026gt; meshEffectPairs; }; Handle Memory Constraint\nI make a max size constraint(99) of vector to limit the number of mesh effect pair\n1 2 3 4 5 6 7 8 9 10 11 12 void eae6320::Graphics::BindMeshWithEffect(Mesh*\u0026amp; mesh, Effect*\u0026amp; effect) { //...... if (meshEffectPairs.size() \u0026gt; 99) { EAE6320_ASSERTF(false, \u0026#34;the mesh number over the limitation, the limitation of mesh in one frame is 99\u0026#34;); Logging::OutputError(\u0026#34;the mesh number over the limitation, the limitation of mesh in one frame is 99\u0026#34;); } //...... } Memory Cost\rBy calling sizeof(), the size of sDataRequiredToRenderAFrame is 224 in x64 platform and 192 in x86 platform. Considering sizeof(vector) can only get a constant value, the real memory cost would be higher.\nThe member type of meshEffectPairs vector is std::pair\u0026lt;eae6320::Graphics::Mesh*\u0026amp;, eae6320::Graphics::Effect*\u0026amp;\u0026gt;, so the size of each member would be 16 in x64 platform and 8 in x86 platform. The member type of constantData_drawCalls is eae6320::Graphics::ConstantBufferFormats::sDrawCall, so the size of each member would be 64 in both platform.\nAs I set the max size of vector is 99, so the max memory cost of sDataRequiredToRenderAFrame would be 8112 in x64 and 7304 in x86.\nExtrapolation/Prediction\rBy extrapolating the position actor would, you can get a smooth movement. The way to make it is using elapsedSecondCount_sinceLastSimulationUpdate. It can be used to smoothly interpolate the position changes of objects based on the time difference between the previous physical simulation and the current rendering. This interpolation compensates for the jitter caused by the different update frequencies of rendering and simulation, ensuring smoother motion of objects between rendered frames.\nGame Sample\rDownload and have a try: MyGame\n","date":"2024-09-27T00:00:00Z","image":"https://joumik.github.io/p/game-engine-ii-assignment05/engine_hu4521113101166852132.jpg","permalink":"https://joumik.github.io/p/game-engine-ii-assignment05/","title":"Game Engine II Assignment05"},{"content":"Gif of My Game\rDefault\rHide Mesh\rPress “F1”\nChange Effect\rPress \u0026ldquo;F2\u0026rdquo;\nBackground Color\rUsing UpdateBackgroundColor function and pass R,G,B,A separately\n1 2 3 4 5 6 7 8 9 10 11 12 13 void eae6320::cMyGame::SubmitDataToBeRendered(const float i_elapsedSecondCount_systemTime, const float i_elapsedSecondCount_sinceLastSimulationUpdate) { //...... //animated background float simulateTime = static_cast\u0026lt;float\u0026gt;(GetElapsedSecondCount_simulation()); float r = (std::cos(9.0f * simulateTime) * 0.1f) + 0.15f; float g = (std::sin(2.0f * simulateTime) * 0.1f) + 0.15f; float b = (-std::cos(5.0f * simulateTime) * 0.2f) + 0.25f; Graphics::UpdateBackgroundColor(r, g, b, backgroundColor.a); //...... } Cache\rTo ensure that the rendered content on each frame is complete, it is necessary to wait for all information about that frame to be ready before rendering. So the content that needs to be rendered in a frame should be saved in the cache first, and the complete data should be obtained from the cache for rendering after all the content in that frame has been loaded to cache. That\u0026rsquo;s also why the sDataRequiredToRenderAFrame structure has two variables, one for the Application thread for caching and one for the render thread for rendering.\nMesh/Effect Pair\rInitialize mesh and effect first\n1 2 3 4 5 6 7 8 9 10 11 eae6320::cResult eae6320::cMyGame::Initialize() { //... Graphics::CreateMesh(vertexData01, indexData01, 7, 9, mesh01); Graphics::CreateMesh(vertexData02, indexData02, 4, 6, mesh02); Graphics::CreateEffect(\u0026#34;data/Shaders/Vertex/standard.shader\u0026#34;, \u0026#34;data/Shaders/Fragment/animatedColor.shader\u0026#34;, effect01); Graphics::CreateEffect(\u0026#34;data/Shaders/Vertex/standard.shader\u0026#34;, \u0026#34;data/Shaders/Fragment/standard.shader\u0026#34;, effect02); //... } Using BindMeshWithEffect function to show mesh with specific effect\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void eae6320::cMyGame::SubmitDataToBeRendered(const float i_elapsedSecondCount_systemTime, const float i_elapsedSecondCount_sinceLastSimulationUpdate) { //...... Graphics::BindMeshWithEffect(mesh01, effect01); if (isDiffShader) { Graphics::BindMeshWithEffect(mesh01, effect01); } else { Graphics::BindMeshWithEffect(mesh01, effect02); } if (isShow) { Graphics::BindMeshWithEffect(mesh02, effect02); } //...... } Mesh Size\rData Members\rConsidering the variable used for reference counting, the data members of Mesh class should like this:\nx64 platform 1 2 3 4 5 6 7 // Variables uint16_t m_referenceCount = 1; // 2 bytes unsigned int s_vertexCount = 0; // 4 bytes unsigned int s_indexCount = 0; // 4 bytes cVertexFormat* s_vertexFormat = nullptr; // 8 bytes(x64) ID3D11Buffer* s_vertexBuffer = nullptr; // 8 bytes(x64) ID3D11Buffer* s_indexBuffer = nullptr; // 8 bytes(x64) x86 platform 1 2 3 4 5 6 7 // Variables uint16_t m_referenceCount = 1; // 2 bytes unsigned int s_vertexCount = 0; // 4 bytes unsigned int s_indexCount = 0; // 4 bytes GLuint s_vertexBufferId = 0; // 4 bytes GLuint s_indexBufferId = 0; // 4 bytes GLuint s_vertexArrayId = 0; // 4 bytes Memory Analysis\rBy debugging, it is interesting to find the size of Mesh in x64 platform is not 34, which is the sum of the size of each variables, but is 40, while it is not 22 but 24 in x86 platform. The reason for this situation is memory alignment.\nWhy it couldn\u0026rsquo;t be smaller?\nTo draw geometry, you must let it know the data size, so you have to store the count info of vertex and index. Direct3D and OpenGL must have the data needed to draw geometry so the related data cannot be removed.\nEffect Size\rData Members\rConsidering the variable used for reference counting, the data members of Effect class should like this:\nx64 platform 1 2 3 4 uint16_t m_referenceCount = 1; //2 bytes cShader* s_vertexShader = nullptr; //8 bytes(x64) cShader* s_fragmentShader = nullptr; //8 bytes(x64) cRenderState s_renderState; //32 bytes x86 platform 1 2 3 4 5 uint16_t m_referenceCount = 1; //2 bytes cShader* s_vertexShader = nullptr; //4 bytes(x86) cShader* s_fragmentShader = nullptr; //4 bytes(x86) cRenderState s_renderState; //1 bytes GLuint s_programId = 0; //4 bytes Memory Analysis\rLike Mesh, because of memory alignment, the size of effect is 56 in x64 platform and 20 in x86 platform\nWhy it couldn\u0026rsquo;t be smaller?\nTo bind shading data, you must know vertex shader and fragment shader, so they must be stored as variables. And OpenGL must have the data needed so the related data cannot be removed.\nsDataRequiredToRenderAFrame\rStruct\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct sColor { float r = 0.f; float g = 0.f; float b = 0.f; float a = 1.f; }; struct sDataRequiredToRenderAFrame { eae6320::Graphics::ConstantBufferFormats::sFrame constantData_frame; sColor backgroundColor; std::vector\u0026lt;std::pair\u0026lt;eae6320::Graphics::Mesh*\u0026amp;, eae6320::Graphics::Effect*\u0026amp;\u0026gt;\u0026gt; meshEffectPairs; }; Handle Memory Constraint\nI make a max size constraint(99) of vector to limit the number of mesh effect pair\n1 2 3 4 5 6 7 8 9 10 11 12 void eae6320::Graphics::BindMeshWithEffect(Mesh*\u0026amp; mesh, Effect*\u0026amp; effect) { //...... if (meshEffectPairs.size() \u0026gt; 99) { EAE6320_ASSERTF(false, \u0026#34;the mesh number over the limitation, the limitation of mesh in one frame is 99\u0026#34;); Logging::OutputError(\u0026#34;the mesh number over the limitation, the limitation of mesh in one frame is 99\u0026#34;); } //...... } Memory Cost\rBy calling sizeof(), the size of sDataRequiredToRenderAFrame is 192 in x64 platform and 176 in x86 platform. Considering sizeof(vector) can only get a constant value, the real memory cost would be higher.\nThe member type of vector is std::pair\u0026lt;eae6320::Graphics::Mesh*\u0026amp;, eae6320::Graphics::Effect*\u0026amp;\u0026gt;, so the size of each member would be 16 in x64 platform and 8 in x86 platform. As I set the max size of vector is 99, so the max memory cost of sDataRequiredToRenderAFrame would be 1776 in x64 and 968 in x86.\nGame Sample\rDownload and have a try: MyGame\n","date":"2024-09-20T00:00:00Z","image":"https://joumik.github.io/p/game-engine-ii-assignment04/engine_hu4521113101166852132.jpg","permalink":"https://joumik.github.io/p/game-engine-ii-assignment04/","title":"Game Engine II Assignment04"},{"content":"Gif of My Game\rGraphics.cpp platform-independent\rMy method of making Graphics platform independent is to derive a View class from Graphics. This class would handle clearing previous images, initializing view, swapping images to the front buffer and cleaning up relevant data.\nClear the back buffer color\rAs mentioned above, Graphics file cleans the back buffer color by using the function provided by view class.\n1 2 3 4 5 //Declare variable eae6320::Graphics::View view; //In RenderFrame function view.ClearPreviousImage(constantData_frame.g_elapsedSecondCount_simulationTime); By passing simulation time to ClearPreviousImage function and doing the similar work as the fragment shader to make the background color animate.\n1 2 3 4 5 6 //Take Direct3D as an example float r = (std::cos(9.0f * g_elapsedSecondCount_simulationTime) * 0.1f) + 0.15f; float g = (std::sin(2.0f * g_elapsedSecondCount_simulationTime) * 0.1f) + 0.15f; float b = (-std::cos(5.0f * g_elapsedSecondCount_simulationTime) * 0.1f) + 0.15f; const float clearColor[4] = { r, g, b, 1.0f }; direct3dImmediateContext-\u0026gt;ClearRenderTargetView(s_renderTargetView, clearColor); And the result has been shown on \u0026ldquo;Gif of My Game\u0026rdquo;.\nEffect\rInitialize\rBy passing vertex shader path and fragment shader path to initialize an effect\n1 2 3 4 5 if (!(result = effect01.InitializeShadingData(\u0026#34;data/Shaders/Vertex/standard.shader\u0026#34;, \u0026#34;data/Shaders/Fragment/animatedColor.shader\u0026#34;))) { EAE6320_ASSERTF(false, \u0026#34;Can\u0026#39;t initialize Graphics without the shading data\u0026#34;); return result; } Memory Analysis\r1 cResult InitializeShadingData(const std::string\u0026amp; vertexShaderPath, const std::string\u0026amp; fragmentShaderPath); By debugging, it is interesting to find the size of string type is different between x86 and x64. The reason for it is that the size of pointer is different in two platforms. Normally, the size of pointer in x86 platform is 4 bytes while it is 8 bytes in x64 platform. And for that, the memory alignment is also different. As a result, the size of string in x86 platform is 28 bytes and in x64 platform is 40 bytes.\nConsidering two string variables are needed, a single effect would take up 56 bytes in x86 platform and 80 bytes in x64 platform.\nWhy it couldn\u0026rsquo;t be smaller?\nBecause two strings pointing to vertex shader path and fragment shader path respectively are necessary.\nMesh\rInitialize\rBy passing vertex data, index data and the size of them to initialize a mesh\n1 2 3 4 5 if (!(result = mesh01.InitializeGeometry(vertexData01, indexData01, 7, 9))) { EAE6320_ASSERTF(false, \u0026#34;Can\u0026#39;t initialize Graphics without the geometry data\u0026#34;); return result; } Memory Analysis\r1 cResult InitializeGeometry(VertexFormats::sVertex_mesh* vertexData, uint16_t* indexData, unsigned int vertexCount, unsigned int indexCount); Because the vertex data and index data are passed as pointers, and as mentioned in effect memory analysis, the size of pointer is different in the two platforms. So two pointers and two unsigned int type variables would take up 16 bytes in x86 platform and 24 bytes in x64 platform.\nWhy it couldn\u0026rsquo;t be smaller?\nTo initialize geometry, you must let it know the size of data, so you have to pass the count info. And considering the performance, using pointers point the address of vertex data and index data.\nGame Sample\rDownload and have a try: MyGame\n","date":"2024-09-13T00:00:00Z","image":"https://joumik.github.io/p/game-engine-ii-assignment03/engine_hu4521113101166852132.jpg","permalink":"https://joumik.github.io/p/game-engine-ii-assignment03/","title":"Game Engine II Assignment03"},{"content":"Gif of My Game\rGPU Capture\rDirect3D\rOpenGL\rInterface Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 //declare variables namespace{ // Geometry Data //-------------- eae6320::Graphics::Mesh mesh; // Shading Data //------------- eae6320::Graphics::Effect effect; } //In RenderFrame function { // Bind the shading data effect.BindShadingData(); // Draw the geometry mesh.Draw(); } //In Initialize function { // Initialize the shading data { if ( !( result = effect.InitializeShadingData() ) ) { EAE6320_ASSERTF( false, \u0026#34;Can\u0026#39;t initialize Graphics without the shading data\u0026#34; ); return result; } } // Initialize the geometry { if ( !( result = mesh.InitializeGeometry() ) ) { EAE6320_ASSERTF( false, \u0026#34;Can\u0026#39;t initialize Graphics without the geometry data\u0026#34; ); return result; } } } //In CleanUp function { result = mesh.CleanUp(); result = effect.CleanUp(); } Platform Difference\rIn Graphics.d3d.cpp, there are variables and functions work for \u0026ldquo;views\u0026rdquo;. Considering that these codes only exist in the d3d file, a view class can be created to handle the relevant logic, and macros (EAE6320_PLATFORM_D3D) can be used in Graphics.cpp to support this part.\n1 2 3 4 5 6 //Graphics.d3d.cpp // In Direct3D \u0026#34;views\u0026#34; are objects that allow a texture to be used a particular way: // A render target view allows a texture to have color rendered to it ID3D11RenderTargetView* s_renderTargetView = nullptr; // A depth/stencil view allows a texture to have depth rendered to it ID3D11DepthStencilView* s_depthStencilView = nullptr; In Graphics.d3d.cpp, direct3dImmediateContext is used to clear image buffer and depth buffer, while the functions provided by OpenGL are used to do the same job in Graphics.gl.cpp. Considering do the similar job like mesh class of this assignment to make Graphics.cpp can be platform-independent.\nGame Sample\rDownload and have a try: MyGame\n","date":"2024-09-06T00:00:00Z","image":"https://joumik.github.io/p/game-engine-ii-assignment02/engine_hu4521113101166852132.jpg","permalink":"https://joumik.github.io/p/game-engine-ii-assignment02/","title":"Game Engine II Assignment02"},{"content":"Gif of My Game\rLog of My Game\rAdd Reference\rThe project needs to add reference to Graphics is Application.\nI found ShaderBuilder has mentioned graphics namespace but don\u0026rsquo;t need to add reference to Graphics. The reason is that ShaderBuilder only uses Graphics::ShaderType and it is an enum, which means it doesn\u0026rsquo;t require any function from Graphics.\nOptional Challenges\rSlow time\rAdd responses to keyboard events in cMyGame.cpp, I use space to slow the time\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void eae6320::cMyGame::UpdateBasedOnInput() { // Is the user pressing the ESC key? if ( UserInput::IsKeyPressed( UserInput::KeyCodes::Escape ) ) { // Exit the application const auto result = Exit( EXIT_SUCCESS ); EAE6320_ASSERT( result ); } // If the user press space, slow the time if (UserInput::IsKeyPressed(UserInput::KeyCodes::Space)) { //slow the time SetTimeRate(0.2f); } // If the user release space, restore the time if (!UserInput::IsKeyPressed(UserInput::KeyCodes::Space)) { //restore the time SetTimeRate(1.0f); } } Add function to iApplication files to set time rate\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* * iApplication.h */ public: void SetTimeRate(const float rate); /* *iApplication.cpp */ //Set the time rate void eae6320::Application::iApplication::SetTimeRate(const float rate) { m_simulationRate = rate; } Thoughts\rorganization\rThe organization of this project is very in line with my previous coding habits, distinguishing different functional modules, which not only makes it easy to find and modify, but also makes the logic clearer.\ncode style\rI think it\u0026rsquo;s a great thing to name every function and variable based on its actual meaning, which not only facilitates future modifications but also makes it easier for readers to understand. Meanwhile, there are numerous detailed comments in the code that make understanding relatively easy.\nI have also found that unnamed namespace is also used in the code, and I think this is a very good thing to prevent functions with naming conflicts.\nconfusion\rThe project configuration has really troubled me for a long time. I haven\u0026rsquo;t had a similar experience before, but fortunately, after communicating with my classmates and step-by-step troubleshooting the configuration, it was resolved. I would like to thank Lehan Li for her help, and I am really grateful for taking the time to help me troubleshoot the configuration problem.\nMy previous operation was to build ExempleGame first and then build BuildExempleGameAssets. This resulted in some lib files used by BuildExempleGameAssets not being generated, as ExempleGame did not reference these libs. Just build the solution directly and there would be no problem. Now it seems a tiny problem, but really stuck me for a long time.\nExpectation\rI am really excited about how to build game engines. When using the UE engine, I often marvel at the powerful features and wonder how they are implemented. However, due to my own ability issues, reading the UE source code has always been a confusing thing for me. I hope to learn a series of graphics knowledge related to game engines, underlying design frameworks, performance optimization algorithms used, and more through this semester\u0026rsquo;s courses\nTime Cost\rThis assignment took me over 10 hours, with the majority of time spent on resolving configuration issues\nGame Sample\rDownload and have a try: MyGame\n","date":"2024-08-26T00:00:00Z","image":"https://joumik.github.io/p/game-engine-ii-assignment01/engine_hu4521113101166852132.jpg","permalink":"https://joumik.github.io/p/game-engine-ii-assignment01/","title":"Game Engine II Assignment01"}]