[{"content":"Gif of My Game\rDefault\rHide Mesh\rPress “F1”\nChange Effect\rPress \u0026ldquo;F2\u0026rdquo;\nBackground Color\rUsing UpdateBackgroundColor function and pass R,G,B,A separately\n1 2 3 4 5 6 7 8 9 10 11 12 13 void eae6320::cMyGame::SubmitDataToBeRendered(const float i_elapsedSecondCount_systemTime, const float i_elapsedSecondCount_sinceLastSimulationUpdate) { //...... //animated background float simulateTime = static_cast\u0026lt;float\u0026gt;(GetElapsedSecondCount_simulation()); float r = (std::cos(9.0f * simulateTime) * 0.1f) + 0.15f; float g = (std::sin(2.0f * simulateTime) * 0.1f) + 0.15f; float b = (-std::cos(5.0f * simulateTime) * 0.2f) + 0.25f; Graphics::UpdateBackgroundColor(r, g, b, backgroundColor.a); //...... } Cache\rTo ensure that the rendered content on each frame is complete, it is necessary to wait for all information about that frame to be ready before rendering. So the content that needs to be rendered in a frame should be saved in the cache first, and the complete data should be obtained from the cache for rendering after all the content in that frame has been loaded to cache. That\u0026rsquo;s also why the sDataRequiredToRenderAFrame structure has two variables, one for the Application thread for caching and one for the render thread for rendering.\nMesh/Effect Pair\rInitialize mesh and effect first\n1 2 3 4 5 6 7 8 9 10 11 eae6320::cResult eae6320::cMyGame::Initialize() { //... Graphics::CreateMesh(vertexData01, indexData01, 7, 9, mesh01); Graphics::CreateMesh(vertexData02, indexData02, 4, 6, mesh02); Graphics::CreateEffect(\u0026#34;data/Shaders/Vertex/standard.shader\u0026#34;, \u0026#34;data/Shaders/Fragment/animatedColor.shader\u0026#34;, effect01); Graphics::CreateEffect(\u0026#34;data/Shaders/Vertex/standard.shader\u0026#34;, \u0026#34;data/Shaders/Fragment/standard.shader\u0026#34;, effect02); //... } Using BindMeshWithEffect function to show mesh with specific effect\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void eae6320::cMyGame::SubmitDataToBeRendered(const float i_elapsedSecondCount_systemTime, const float i_elapsedSecondCount_sinceLastSimulationUpdate) { //...... Graphics::BindMeshWithEffect(mesh01, effect01); if (isDiffShader) { Graphics::BindMeshWithEffect(mesh01, effect01); } else { Graphics::BindMeshWithEffect(mesh01, effect02); } if (isShow) { Graphics::BindMeshWithEffect(mesh02, effect02); } //...... } Mesh Size\rData Members\rConsidering the variable used for reference counting, the data members of Mesh class should like this:\nx64 platform 1 2 3 4 5 6 7 // Variables uint16_t m_referenceCount = 1; // 2 bytes unsigned int s_vertexCount = 0; // 4 bytes unsigned int s_indexCount = 0; // 4 bytes cVertexFormat* s_vertexFormat = nullptr; // 8 bytes(x64) ID3D11Buffer* s_vertexBuffer = nullptr; // 8 bytes(x64) ID3D11Buffer* s_indexBuffer = nullptr; // 8 bytes(x64) x86 platform 1 2 3 4 5 6 7 // Variables uint16_t m_referenceCount = 1; // 2 bytes unsigned int s_vertexCount = 0; // 4 bytes unsigned int s_indexCount = 0; // 4 bytes GLuint s_vertexBufferId = 0; // 4 bytes GLuint s_indexBufferId = 0; // 4 bytes GLuint s_vertexArrayId = 0; // 4 bytes Memory Analysis\rBy debugging, it is interesting to find the size of Mesh in x64 platform is not 34, which is the sum of the size of each variables, but is 40, while it is not 22 but 24 in x86 platform. The reason for this situation is memory alignment.\nWhy it couldn\u0026rsquo;t be smaller?\nTo draw geometry, you must let it know the data size, so you have to store the count info of vertex and index. Direct3D and OpenGL must have the data needed to draw geometry so the related data cannot be removed.\nEffect Size\rData Members\rConsidering the variable used for reference counting, the data members of Effect class should like this:\nx64 platform 1 2 3 4 uint16_t m_referenceCount = 1; //2 bytes cShader* s_vertexShader = nullptr; //8 bytes(x64) cShader* s_fragmentShader = nullptr; //8 bytes(x64) cRenderState s_renderState; //32 bytes x86 platform 1 2 3 4 5 uint16_t m_referenceCount = 1; //2 bytes cShader* s_vertexShader = nullptr; //4 bytes(x86) cShader* s_fragmentShader = nullptr; //4 bytes(x86) cRenderState s_renderState; //1 bytes GLuint s_programId = 0; //4 bytes Memory Analysis\rLike Mesh, because of memory alignment, the size of effect is 56 in x64 platform and 20 in x86 platform\nWhy it couldn\u0026rsquo;t be smaller?\nTo bind shading data, you must know vertex shader and fragment shader, so they must be stored as variables. And OpenGL must have the data needed so the related data cannot be removed.\nsDataRequiredToRenderAFrame\rStruct\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct sColor { float r = 0.f; float g = 0.f; float b = 0.f; float a = 1.f; }; struct sDataRequiredToRenderAFrame { eae6320::Graphics::ConstantBufferFormats::sFrame constantData_frame; sColor backgroundColor; std::vector\u0026lt;std::pair\u0026lt;eae6320::Graphics::Mesh*\u0026amp;, eae6320::Graphics::Effect*\u0026amp;\u0026gt;\u0026gt; meshEffectPairs; }; Handle Memory Constraint\nI make a max size constraint(99) of vector to limit the number of mesh effect pair\n1 2 3 4 5 6 7 8 9 10 11 12 void eae6320::Graphics::BindMeshWithEffect(Mesh*\u0026amp; mesh, Effect*\u0026amp; effect) { //...... if (meshEffectPairs.size() \u0026gt; 99) { EAE6320_ASSERTF(false, \u0026#34;the mesh number over the limitation, the limitation of mesh in one frame is 99\u0026#34;); Logging::OutputError(\u0026#34;the mesh number over the limitation, the limitation of mesh in one frame is 99\u0026#34;); } //...... } Memory Cost\rBy calling sizeof(), the size of sDataRequiredToRenderAFrame is 192 in x64 platform and 176 in x86 platform. Considering sizeof(vector) can only get a constant value, the real memory cost would be higher.\nThe member type of vector is std::pair\u0026lt;eae6320::Graphics::Mesh*\u0026amp;, eae6320::Graphics::Effect*\u0026amp;\u0026gt;, so the size of each member would be 16 in x64 platform and 8 in x86 platform. As I set the max size of vector is 99, so the max memory cost of sDataRequiredToRenderAFrame would be 1776 in x64 and 968 in x86.\nGame Sample\rDownload and have a try: MyGame\n","date":"2024-09-20T00:00:00Z","image":"https://joumik.github.io/p/game-engine-ii-assignment04/engine_hu4521113101166852132.jpg","permalink":"https://joumik.github.io/p/game-engine-ii-assignment04/","title":"Game Engine II Assignment04"},{"content":"Gif of My Game\rGraphics.cpp platform-independent\rMy method of making Graphics platform independent is to derive a View class from Graphics. This class would handle clearing previous images, initializing view, swapping images to the front buffer and cleaning up relevant data.\nClear the back buffer color\rAs mentioned above, Graphics file cleans the back buffer color by using the function provided by view class.\n1 2 3 4 5 //Declare variable eae6320::Graphics::View view; //In RenderFrame function view.ClearPreviousImage(constantData_frame.g_elapsedSecondCount_simulationTime); By passing simulation time to ClearPreviousImage function and doing the similar work as the fragment shader to make the background color animate.\n1 2 3 4 5 6 //Take Direct3D as an example float r = (std::cos(9.0f * g_elapsedSecondCount_simulationTime) * 0.1f) + 0.15f; float g = (std::sin(2.0f * g_elapsedSecondCount_simulationTime) * 0.1f) + 0.15f; float b = (-std::cos(5.0f * g_elapsedSecondCount_simulationTime) * 0.1f) + 0.15f; const float clearColor[4] = { r, g, b, 1.0f }; direct3dImmediateContext-\u0026gt;ClearRenderTargetView(s_renderTargetView, clearColor); And the result has been shown on \u0026ldquo;Gif of My Game\u0026rdquo;.\nEffect\rInitialize\rBy passing vertex shader path and fragment shader path to initialize an effect\n1 2 3 4 5 if (!(result = effect01.InitializeShadingData(\u0026#34;data/Shaders/Vertex/standard.shader\u0026#34;, \u0026#34;data/Shaders/Fragment/animatedColor.shader\u0026#34;))) { EAE6320_ASSERTF(false, \u0026#34;Can\u0026#39;t initialize Graphics without the shading data\u0026#34;); return result; } Memory Analysis\r1 cResult InitializeShadingData(const std::string\u0026amp; vertexShaderPath, const std::string\u0026amp; fragmentShaderPath); By debugging, it is interesting to find the size of string type is different between x86 and x64. The reason for it is that the size of pointer is different in two platforms. Normally, the size of pointer in x86 platform is 4 bytes while it is 8 bytes in x64 platform. And for that, the memory alignment is also different. As a result, the size of string in x86 platform is 28 bytes and in x64 platform is 40 bytes.\nConsidering two string variables are needed, a single effect would take up 56 bytes in x86 platform and 80 bytes in x64 platform.\nWhy it couldn\u0026rsquo;t be smaller?\nBecause two strings pointing to vertex shader path and fragment shader path respectively are necessary.\nMesh\rInitialize\rBy passing vertex data, index data and the size of them to initialize a mesh\n1 2 3 4 5 if (!(result = mesh01.InitializeGeometry(vertexData01, indexData01, 7, 9))) { EAE6320_ASSERTF(false, \u0026#34;Can\u0026#39;t initialize Graphics without the geometry data\u0026#34;); return result; } Memory Analysis\r1 cResult InitializeGeometry(VertexFormats::sVertex_mesh* vertexData, uint16_t* indexData, unsigned int vertexCount, unsigned int indexCount); Because the vertex data and index data are passed as pointers, and as mentioned in effect memory analysis, the size of pointer is different in the two platforms. So two pointers and two unsigned int type variables would take up 16 bytes in x86 platform and 24 bytes in x64 platform.\nWhy it couldn\u0026rsquo;t be smaller?\nTo initialize geometry, you must let it know the size of data, so you have to pass the count info. And considering the performance, using pointers point the address of vertex data and index data.\nGame Sample\rDownload and have a try: MyGame\n","date":"2024-09-13T00:00:00Z","image":"https://joumik.github.io/p/game-engine-ii-assignment03/engine_hu4521113101166852132.jpg","permalink":"https://joumik.github.io/p/game-engine-ii-assignment03/","title":"Game Engine II Assignment03"},{"content":"Gif of My Game\rGPU Capture\rDirect3D\rOpenGL\rInterface Code\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 //declare variables namespace{ // Geometry Data //-------------- eae6320::Graphics::Mesh mesh; // Shading Data //------------- eae6320::Graphics::Effect effect; } //In RenderFrame function { // Bind the shading data effect.BindShadingData(); // Draw the geometry mesh.Draw(); } //In Initialize function { // Initialize the shading data { if ( !( result = effect.InitializeShadingData() ) ) { EAE6320_ASSERTF( false, \u0026#34;Can\u0026#39;t initialize Graphics without the shading data\u0026#34; ); return result; } } // Initialize the geometry { if ( !( result = mesh.InitializeGeometry() ) ) { EAE6320_ASSERTF( false, \u0026#34;Can\u0026#39;t initialize Graphics without the geometry data\u0026#34; ); return result; } } } //In CleanUp function { result = mesh.CleanUp(); result = effect.CleanUp(); } Platform Difference\rIn Graphics.d3d.cpp, there are variables and functions work for \u0026ldquo;views\u0026rdquo;. Considering that these codes only exist in the d3d file, a view class can be created to handle the relevant logic, and macros (EAE6320_PLATFORM_D3D) can be used in Graphics.cpp to support this part.\n1 2 3 4 5 6 //Graphics.d3d.cpp // In Direct3D \u0026#34;views\u0026#34; are objects that allow a texture to be used a particular way: // A render target view allows a texture to have color rendered to it ID3D11RenderTargetView* s_renderTargetView = nullptr; // A depth/stencil view allows a texture to have depth rendered to it ID3D11DepthStencilView* s_depthStencilView = nullptr; In Graphics.d3d.cpp, direct3dImmediateContext is used to clear image buffer and depth buffer, while the functions provided by OpenGL are used to do the same job in Graphics.gl.cpp. Considering do the similar job like mesh class of this assignment to make Graphics.cpp can be platform-independent.\nGame Sample\rDownload and have a try: MyGame\n","date":"2024-09-06T00:00:00Z","image":"https://joumik.github.io/p/game-engine-ii-assignment02/engine_hu4521113101166852132.jpg","permalink":"https://joumik.github.io/p/game-engine-ii-assignment02/","title":"Game Engine II Assignment02"},{"content":"Gif of My Game\rLog of My Game\rAdd Reference\rThe project needs to add reference to Graphics is Application.\nI found ShaderBuilder has mentioned graphics namespace but don\u0026rsquo;t need to add reference to Graphics. The reason is that ShaderBuilder only uses Graphics::ShaderType and it is an enum, which means it doesn\u0026rsquo;t require any function from Graphics.\nOptional Challenges\rSlow time\rAdd responses to keyboard events in cMyGame.cpp, I use space to slow the time\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void eae6320::cMyGame::UpdateBasedOnInput() { // Is the user pressing the ESC key? if ( UserInput::IsKeyPressed( UserInput::KeyCodes::Escape ) ) { // Exit the application const auto result = Exit( EXIT_SUCCESS ); EAE6320_ASSERT( result ); } // If the user press space, slow the time if (UserInput::IsKeyPressed(UserInput::KeyCodes::Space)) { //slow the time SetTimeRate(0.2f); } // If the user release space, restore the time if (!UserInput::IsKeyPressed(UserInput::KeyCodes::Space)) { //restore the time SetTimeRate(1.0f); } } Add function to iApplication files to set time rate\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* * iApplication.h */ public: void SetTimeRate(const float rate); /* *iApplication.cpp */ //Set the time rate void eae6320::Application::iApplication::SetTimeRate(const float rate) { m_simulationRate = rate; } Thoughts\rorganization\rThe organization of this project is very in line with my previous coding habits, distinguishing different functional modules, which not only makes it easy to find and modify, but also makes the logic clearer.\ncode style\rI think it\u0026rsquo;s a great thing to name every function and variable based on its actual meaning, which not only facilitates future modifications but also makes it easier for readers to understand. Meanwhile, there are numerous detailed comments in the code that make understanding relatively easy.\nI have also found that unnamed namespace is also used in the code, and I think this is a very good thing to prevent functions with naming conflicts.\nconfusion\rThe project configuration has really troubled me for a long time. I haven\u0026rsquo;t had a similar experience before, but fortunately, after communicating with my classmates and step-by-step troubleshooting the configuration, it was resolved. I would like to thank Lehan Li for her help, and I am really grateful for taking the time to help me troubleshoot the configuration problem.\nMy previous operation was to build ExempleGame first and then build BuildExempleGameAssets. This resulted in some lib files used by BuildExempleGameAssets not being generated, as ExempleGame did not reference these libs. Just build the solution directly and there would be no problem. Now it seems a tiny problem, but really stuck me for a long time.\nExpectation\rI am really excited about how to build game engines. When using the UE engine, I often marvel at the powerful features and wonder how they are implemented. However, due to my own ability issues, reading the UE source code has always been a confusing thing for me. I hope to learn a series of graphics knowledge related to game engines, underlying design frameworks, performance optimization algorithms used, and more through this semester\u0026rsquo;s courses\nTime Cost\rThis assignment took me over 10 hours, with the majority of time spent on resolving configuration issues\nGame Sample\rDownload and have a try: MyGame\n","date":"2024-08-26T00:00:00Z","image":"https://joumik.github.io/p/game-engine-ii-assignment01/engine_hu4521113101166852132.jpg","permalink":"https://joumik.github.io/p/game-engine-ii-assignment01/","title":"Game Engine II Assignment01"}]